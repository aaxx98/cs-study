# 알고리즘

## 키워드

**시간복잡도(Time Complexity)**

- 알고리즘 수행 시간 증가 정도를 입력 크기 기준으로 측정

**공간복잡도(Space Complexity)**

- 알고리즘 수행 시 필요한 메모리 양을 입력 크기 기준으로 측정

**탐색(Search)**

- 자료 구조나 그래프에서 원하는 값을 찾는 과정

**BFS (Breadth-First Search)**

- 너비 우선 탐색
  - 단계별로 가까운 노드부터 탐색
  - 큐(Queue) 사용
  - 최단 경로 탐색에 적합

**DFS (Depth-First Search)**

- 깊이 우선 탐색
  - 한 방향으로 끝까지 탐색 후 되돌아감
  - 스택(Stack) 또는 재귀 사용
  - 상태 공간 탐색, 백트래킹에 적합

**NP (Next Permutation)**

- 순열을 사전순으로 다음 순서로 변환하는 알고리즘
  - 주어진 배열이나 문자열에서 현재 순열보다 사전순으로 큰 순열 생성

**비트 마스크(Bitmask)**

- 정수의 이진수 표현을 자료 구조로 활용
  - 집합 표현에 주로 사용
  - 비트 연산(AND, OR, XOR)으로 효율적 처리 가능

**정렬(Sorting)**

- 자료를 특정 순서대로 재배치하는 알고리즘

## 질문과 답변

### 1. 비트 마스크(Bitmask)는 알고리즘 문제에서 어떻게 사용되는가?

- 정수의 이진 표현을 이용해 집합이나 상태를 효율적으로 표현하는 기법
  - 부분 집합 탐색, 방문 여부 체크, DP 상태 압축 등에 사용
  - 각 비트가 특정 상태의 on/off를 나타낸다.
    - ex) {1, 2, 3}의 부분집합을 111(2) = 7로 표현
  - 비트 연산으로 빠른 처리가 가능하다.
    - OR(|) - 원소 추가, 합집합
    - AND(&) - 원소 포함 여부 확인, 교집합
    - XOR(^) - 원소가 있으면 제거, 없으면 추가, 대칭차집합
    - NOT(~) - 비트 반전, 여집합

### 2. BFS와 DFS의 차이점(구현 방식, 시간, 메모리, 용도)

- BFS

  - 큐(Queue) 사용
  - 가까운 곳부터 탐색, 최단경로 찾기
  - 시간복잡도: O(V + E) (V는 정점, E는 간선)
  - 메모리 많이 사용
    - 탐색 한 단계의 모든 노드를 큐에 저장해야 함

- DFS

  - 스택(Stack) 또는 재귀 사용
  - 모든 경로 탐색, 백트래킹, 사이클 검출
  - 시간복잡도: O(V + E) (V는 정점, E는 간선)
  - 메모리 적게 사용
    - 탐색 후 스택에서 pop
    - 깊이에 해당하는 노드 개수만큼만 메모리 사용

### 3. 알고리즘의 시간복잡도를 가늠하는 방법

- 입력 크기 N에 대한 연산 횟수를 분석한다.
  - 반복문의 중첩 정도를 확인한다.
  - 재귀 함수의 호출 횟수와 깊이를 계산한다.
  - Big-O 표기법
    - 상수 무시
    - 최고차항만 고려
- 대표적인 복잡도
  - O(1): 상수 시간
  - O(log N): 이진 탐색
  - O(N): 선형 탐색
  - O(N log N): 정렬 알고리즘
  - O(N²): 중첩 반복문
