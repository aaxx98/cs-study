# 디자인 패턴 질문 & 답변 정리

## 패턴 구현 방식 비교

### 1. 객체 어댑터 패턴과 클래스 어댑터 패턴의 차이점 및 사용 시점
| 구분 | 객체 어댑터 패턴 | 클래스 어댑터 패턴 |
|------|----------------|------------------|
| 구현 방식 | 기존 객체 포함 (Composition) | 기존 클래스 상속 (Inheritance) |
| 장점 | 다중 상속 불가 언어(Java 등)에서도 사용 가능, 유연성 높음 | 기존 클래스 동작 직접 재정의 가능, 코드 간결 |
| 단점 | 위임 코드 필요, Adaptee protected 멤버 접근 불가 | 다중 상속 필요 시 제약, 유연성 낮음 |
| 사용 시점 | 대부분의 경우 사용 (유연성) | 상속 통한 직접 수정 필요 시 사용 |

- **실무 사용:** 객체 어댑터가 대부분 선호됨.
- **특수 상황:** 성능 최적화나 단순 프로젝트 시 클래스 어댑터 사용 가능.

---

### 2. 템플릿 메소드 패턴을 abstract 클래스 대신 interface로 구현 가능 여부
- Java 8 이후 가능 (`default` 메서드 사용).
- 제한 사항:
    - 상태(state) 관리 불가
    - `final`로 메서드 선언 불가
    - `protected` 접근 불가
- 권장: 공통 상태와 흐름 관리가 필요한 경우 abstract 클래스 사용
- 간단한 알고리즘 틀: interface + default method 가능

---

## 유사 패턴 간 차이점

### 3. 템플릿 메서드 패턴 vs 전략(Strategy) 패턴
| 구분 | 템플릿 메서드 패턴 | 전략 패턴 |
|------|-----------------|-----------|
| 구현 방식 | 상속(Inheritance) | 구성(Composition) |
| 변경 시점 | 컴파일 타임 | 런타임 |
| 제어 | 부모 클래스 | 클라이언트 |
| 결합도 | 강결합 | 약결합 |
| 장점 | 코드 재사용 높음, 알고리즘 구조 강제 | 런타임 유연성, 재사용성 높음 |
| 단점 | 단일 상속 제한, 결합도 높음 | 클래스 수 증가, 클라이언트가 전략 알아야 함 |

---

### 4. 어댑터 패턴 vs Facade 패턴
| 구분 | 어댑터(Adapter) | 퍼사드(Facade) |
|------|----------------|----------------|
| 목적 | 인터페이스 변환, 호환성 제공 | 복잡한 시스템 단순화 |
| 초점 | 기존 클래스 호환 | 여러 서브시스템 감춤 |
| 구조 | Target 인터페이스 맞춤 | 여러 객체를 하나로 묶음 |
| 장점 | 기존 코드 수정 없이 새로운 인터페이스 적용 | 시스템 단순화, 유지보수 용이 |
| 단점 | 변환 계층 추가로 복잡도 증가 | Facade가 커지면 또 다른 복잡 구조 |

- **함께 쓰는 경우:**  
  외부 라이브러리 단순화(Facade) + 인터페이스 변환(Adapter)

---

### 5. 팩토리 메소드 패턴 vs 추상 팩토리 패턴
| 구분 | 팩토리 메소드 | 추상 팩토리 |
|------|----------------|-------------|
| 목적 | 객체 생성 책임 서브클래스 위임 | 관련 객체 묶음(제품군) 생성 |
| 생성 대상 | 하나의 제품 | 여러 제품군 |
| 확장 방식 | 새 제품 추가 시 서브클래스 생성 | 제품군 전체를 새로운 팩토리로 교체 |
| 구조 | 상속 기반 | 조합 기반 |
| 예시 | `ShapeFactory.createShape()` | `GUIFactory.createButton()`, `createTextField()` |

---

## 패턴과 SOLID 원칙

### 6. 템플릿 메소드와 LSP 위반 가능성
**문제:** 서브클래스가 상위 클래스의 알고리즘 전제조건(전처리, 순서, 반환값 등)을 깨뜨리는 경우
```java
abstract class Bird {
    public final void move() {
        takeOff();
        fly(); // 모든 새가 날 수 있다고 가정 → Penguin에서는 X
        land();
    }
    protected abstract void fly();
}

class Penguin extends Bird {
    protected void fly() {
        throw new UnsupportedOperationException(); // X. LSP 위반
    }
}
```

## 해결 방안

- 상속 계층 재설계 (`FlyingBird` 분리)
- 훅(Hook) 메소드 사용
- 전략 패턴(Strategy)으로 상속 대신 합성 사용
- `final` + `protected`로 오버라이드 범위 제한

---

## 멀티스레드와 싱글톤

### 7. Holder Pattern vs Double-Checked Locking(DCL)

| 구분 | DCL | Holder Pattern |
|------|-----|----------------|
| 동작 | 인스턴스가 없을 때만 `synchronized` | 내부 static 클래스 로딩 시점에 인스턴스 생성 |
| 문제점 | 명령어 재배치, 가시성 문제, `volatile` 필요 | JVM 클래스 로딩에서 thread-safe 자동 보장 |
| 안전성 | Java 5 이후 `volatile` 사용 시 안전 | 언어 차원에서 안전, 단순하고 오류 가능성 낮음 |
| 성능 | 첫 호출 시 lock 비용 | 동기화 불필요, 게으른 초기화 |

### 8. JVM의 static 처리
- 클래스 로딩 시점에 static 변수/블록 초기화
- Initialization 단계에서 static 변수 실제 값 할당, static 블록 실행
- JVM이 초기화를 직렬화하여 멀티스레드 안전 보장

### 9. Lazy Initialization + DCL 방식의 문제
- 명령어 재배치 가능 → 미완성 객체 노출
- 메모리 가시성 문제 → `volatile` 없으면 다른 스레드에서 캐시 참조
- 복잡성 → Holder Pattern 사용 권장

---

## 패턴 적용 범위 / 시나리오

### 10. 어댑터 패턴 활용 범위
**핵심:** 인터페이스 호환 문제 해결

**활용 사례:**
- 새 라이브러리/시스템 통합
- 서로 다른 모듈 호환성 조정
- 테스트/Mock 객체 작성
- 데이터 포맷 변환 (JSON ↔ XML)

**결론:**  
기존 코드에 새 시스템을 붙이는 경우뿐 아니라, **인터페이스 불일치 모든 상황에서 사용 가능**