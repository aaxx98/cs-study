# 네트워크

## 연결 & 보안

### 키워드

**3-way Handshake(연결 성립)**
- TCP 연결 설정 절차. SYN → SYN+ACK → ACK 순서로 서로의 연결 준비를 확인.
- 단계:
    - **1단계**: 클라이언트 → 서버 SYN 패킷 전송
    - **2단계**: 서버 → 클라이언트 SYN/ACK 패킷 전송 (ACK: x+1)
    - **3단계**: 클라이언트 → 서버 ACK 패킷 전송 (ACK: y+1)

**4-way Handshake (연결 해제)**
- TCP 연결 해제 과정으로, FIN과 ACK 패킷이 네 번 교환되며 양방향 통신을 종료한다.
- 단계:
    - **1단계**: 클라이언트 → 서버. FIN 플래그 전송 (연결 종료 요청)
    - **2단계**: 서버 → 클라이언트. ACK 전송, CLOSE_WAIT 상태 (남은 데이터 전송)
    - **3단계**: 서버 → 클라이언트. FIN 플래그 전송 (연결 종료 준비 완료)
    - **4단계**: 클라이언트 → 서버. ACK 전송, TIME_WAIT 후 연결 종료

**TIME_WAIT**
- TCP 종료 후 일정 시간 대기 상태. 중복 패킷 방지 및 연결 완전 종료 보장.

**대칭키 암호화(Symmetric Key)**
- 암호화와 복호화에 같은 키 사용
- 장점: 속도가 매우 빠름
- 단점 : 키 전달 과정에서 해킹 위험
- 보안 요소 : Confidentiality
- 예: AES, DES.

**공개키 암호화**
- 암호화와 복호화에 다른 키 사용 (공개키 + 비밀키)
- 장점: 키 분배 문제 해결, 공개키는 공개 가능
- 단점: 암호화/복호화가 복잡하고 느림
- 보안 : Confidentiality (+ MAC/전자서명으로 Integrity, Authenticity 보완)
- 예: RSA.

**하이브리드 암호화**
- 공개키로 세션키(대칭키)를 안전하게 교환 → 이후 대칭키로 실제 데이터 암호화. (SSL/TLS 기반) HTTPS에서 사용.

**공개키**
- 대중에게 공개. 암호화/서명 검증에 사용.

**개인키**
- 소유자만 소유. 복호화/서명 생성에 사용.

**디지털 인증서 (Digital Certificate)**
- 신뢰기관(CA)이 발급하는 서버 인증 정보. 공개키, 도메인, 서명 포함.

**CA (Certificate Authority)**
- 신뢰성이 검증된 기관으로, 서버의 신원 보증 및 공개키를 담은 인증서 발급 역할.

**SSL/TLS**
- HTTPS에서 사용되는 보안 프로토콜로, 인증·암호화·무결성을 제공

**HTTPS 통신 흐름**
1. 서버(A)가 공개키와 개인키 생성
2. 신뢰할 수 있는 CA(Certificate Authority)와 계약, 공개키 관리 위임
3. CA가 서버 정보와 공개키를 담은 인증서를 CA의 개인키로 암호화하여 제공
4. 클라이언트가 HTTPS 요청 시, 서버는 암호화된 인증서 전송
5. 브라우저가 CA의 공개키(기본 내장)로 인증서 복호화하여 서버 공개키 획득
6. 클라이언트가 대칭키(pre-master-key) 생성 후 서버 공개키로 암호화하여 전송
7. 서버가 개인키로 대칭키 복호화
8. 	이후 클라이언트-서버 간 통신은 대칭키로 암호화/복호화

**TLS/SSL Handshake**
- HTTPS에서 클라이언트와 서버 간 신뢰성 검증 및 데이터 암호화를 위한 키 교환을 진행하는 과정
- 클라이언트와 서버 간 암호화 통신을 위해 세션 키를 안전하게 교환하는 과정으로, 프로토콜 버전 협상, 암호화 알고리즘 선택, 인증서 검증, 세션 키 생성 등의 단계를 포함

- 진행 순서:
    - **ClientHello (1단계)**: 클라이언트 → 서버: 지원 버전, 암호 알고리즘 등을 전송
    - **ServerHello & Certificate**: 서버 → 클라이언트: 선택된 암호 알고리즘, 세션 ID, CA 인증서 (공개키 포함) 전달
    - **서버 인증서 검증**: 클라이언트가 받은 CA 인증서의 유효성을 CA 목록에서 확인하여 서버 신뢰성 검증
    - **대칭키 생성**: 클라이언트가 난수를 생성하여 서버의 공개키로 암호화 후 전송. 서버는 개인키로 복호화하여 대칭 마스터 키를 생성
    - **Finished 교환**: 교환 내역을 해싱 후 대칭키로 암호화하여 교환, 서로 해싱값을 비교하여 인증 완료

**SSL/TLS 계층 위치**
- OSI 표현 계층과 전송 계층 사이에서 작동.

**SSL 인증서**
- 웹사이트의 신원을 확인하고 암호화 통신을 가능하게 하는 디지털 인증서
- 공개키, 도메인 정보, 발급 기관 정보 등을 포함

**CA 인증서**
- Certificate Authority(인증 기관)가 발급한 인증서
- SSL 인증서의 신뢰성을 보증하며, 브라우저에 사전 설치된 루트 CA를 통해 인증서 체인을 검증함

**인증서**
- 서버의 신원을 증명하기 위한 파일
- HTTPS 연결 시 신뢰성을 확보

**세션**
- 클라이언트와 서버 간의 상태를 유지하기 위한 논리적 연결

**쿠키**
- 클라이언트 측에 저장되는 작은 데이터 조각. 세션 유지를 도움.

---
### 질문답

**[TCP] 3 way handshake & 4 way handshake**

***1. TCP에서 사용하는 network congestion avoidance algorithm은 뭔가?***
- ***Slow Start***: 초기에 CWND를 1 MSS부터 시작해 지수적으로 증가
- ***Congestion Avoidance***: 임계값(ssthresh) 도달 후 선형적으로 증가
- ***Fast Retransmit***: 3개의 중복 ACK 받으면 즉시 재전송
- ***Fast Recovery***: 패킷 손실 감지 시 CWND를 절반으로 줄이고 선형 증가 재개
- ***Tahoe, Reno, New Reno, CUBIC*** 등 다양한 알고리즘 존재

**대칭키 & 공개키**

***1. 공개키/비밀키로 계속 통신하지 않고 대칭키를 주고받아서 통신하는 이유***
- 공개키 암호는 느림 → 대칭키로 교환 후 데이터 통신 시 속도 개선
- 대칭키: 빠른 데이터 암호화
- 공개키: 초기 키 교환용 안전 통로

***2. 공개키 암호와 방식의 단점을 MAC(Message Authentication Code)나 전자 서명(Digital Signature)으로 해결한다는데 어떻게 해결하나?***
- **공개키 암호화 방식의 단점**
    - 연산 비용 높음
    - 암호화 속도 느림
    - 키 관리 부담

- **MAC**
    - 송수신자 공유 키를 기반으로 생성
    - 메시지 **위·변조 여부 확인 가능**
    - **무결성**을 보장하지만 부인 방지 기능은 없음

- **전자 서명**
    - 송신자가 비밀키로 서명, 수신자는 공개키로 검증
    - 메시지 위·변조 감지 + 송신자 부인 방지 가능
    - **인증과 무결성 모두 제공**


***3. 로그인, 유저 비밀번호 저장에 사용하는 암호화 방식은 어떤 것이 있을까?***
- **해시 함수 사용** (복호화 불가능한 단방향)
- **bcrypt**: 가장 권장, Salting 자동, 속도 조절 가능 (무차별 대입 공격 방어)
- **scrypt**: 메모리 많이 사용, ASIC 공격 방어
- **Argon2**: 최신 알고리즘, 메모리 하드, 가장 안전
- **PBKDF2**: 많은 반복 연산으로 보안성 향상
- ❌ **SHA-256, MD5 단독 사용 금지**: 너무 빠르고 Rainbow Table 공격에 취약
- **Salt 추가 필수**: 같은 비밀번호도 다른 해시값 생성

**TLS/SSL HandShake**

***1. HTTPS 통신에서 SSL 인증서와 CA 인증서는 각각 어떤 역할을 하는가?***
- **SSL 인증서 (서버 인증서)**
    - 서버의 공개키와 신원 정보를 담고 있음
    - 클라이언트가 서버의 진위 여부를 검증할 때 사용
    - 공개키, 도메인 정보, 발급 기관 정보 등을 포함

- **CA 인증서 (Certificate Authority)**
    - 신뢰할 수 있는 기관이 발급한 인증서
    - SSL 인증서가 진짜인지 보증하는 역할
    - 브라우저나 OS는 기본적으로 여러 CA를 신뢰 목록에 가지고 있음
    - SSL 인증서의 신뢰성을 보증하며, 브라우저에 사전 설치된 루트 CA를 통해 인증서 체인을 검증함