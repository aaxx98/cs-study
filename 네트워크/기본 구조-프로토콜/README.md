# 네트워크

## 네트워크 기본 구조 & 프로토콜

### 키워드

**OSI 7계층**
- 네트워크 통신이 일어나는 과정을 7단계로 나눈 표준 모델.계층 간 역할을 분리하여 구조적 설계 및 문제 추적 용이.
1. **물리 계층 (Physical)**:
    - 데이터를 전기 신호나 광 신호를 통해 비트를 전송하는 계층
    - 리피터, 케이블, 허브
2. **데이터 링크 계층 (Data Link)**:
    - 물리 계층의 정보를 안전하게 전달, Mac 주소 통신, 에러 검출 및 흐름 제어
    - 브릿지, 스위치
3. **네트워크 계층 (Network)**:
    - 데이터를 목적지까지 안전하고 빠르게 전달, 라우팅, IP 주소 지정
    - 라우터, IP
4. **전송 계층 (Transport)**:
    - 포트를 열어 프로그램 간 전송 제공, 신뢰성/비신뢰성 통신
    - TCP, UDP
5. **세션 계층 (Session)**:
    - 논리적 연결 담당, TCP/IP 세션 생성 및 제거
    - API, Socket
6. **표현 계층 (Presentation)**
    - 데이터 표현의 독립성 제공, 암호화, 인코딩, 압축
    - JPEG, MPEG
7. **응용 계층 (Application)**
    - 사용자 인터페이스, 응용 서비스 제공 (전자우편, 데이터베이스 관리 등)
    - HTTP, FTP, DNS

**TCP (Transmission Control Protocol)**
- 신뢰성 있는 연결 지향형 프로토콜.
- 데이터 재전송, 순서 제어, 흐름제어·혼잡제어 수행.
- 속도 낮음.

**TCP가 보장하는 Reliable Network의 4가지 문제**
- 손실 (Loss) : 패킷이 손실될 수 있음
- 순서 변경 (Reordering) : 패킷 순서가 바뀔 수 있음
- 혼잡 (Congestion)	: 네트워크가 혼잡해질 수 있음
- 과부하 (Overload)	: 수신자가 과부하 상태가 될 수 있음

**흐름 제어 (Flow Control)** :
- 송신/수신측 속도 차이 해결 (End-to-End).
- **Stop and Wait**
    - 매번 전송한 패킷의 확인 응답을 받아야 다음 패킷 전송
- **Sliding Window (Go Back N ARQ)**
    - 혼잡 시 전송속도를 절반으로 줄이고 혼잡이 없으면 선형적으로 증가하는 방법.
    - 수신측 윈도우 크기만큼 확인 응답 없이 전송 가능
    - 동적으로 흐름 제어.
    - RWND(Receive Window) 사용

**혼잡 제어 (Congestion Control)**
- 송신/네트워크 처리 속도 차이 해결.
- 순서: Slow Start → AIMD → Fast Retransmit → Fast Recovery
- **Slow Start**
    - 지수 함수적으로 증가(ACK마다 +1), 혼잡 발생 시 1로 감소. 이후 임계값까지 지수 증가, 그 후 선형 증가
    - 연결 초반 전송량을 지수적으로 증가시켜 네트워크 용량 파악.
- **AIMD (Additive Increase / Multiplicative Decrease)**
    - 윈도우 크기를 1씩 증가, 실패 시 절반으로 감소. 공평하지만 초기 대역폭 활용이 느림
- **Fast Retransmit**
    - 중복 ACK 3개 수신 시 즉시 재전송, 타임아웃 대기 불필요
    - 중복된 ACK 감지 시, 손실 패킷을 즉시 재전송하여 효율 높임.
- **Fast Recovery**
    - 혼잡 발생 시 윈도우를 1이 아닌 절반으로 줄이고 선형 증가.

**RWND (Receive Window)**
- 수신 측 버퍼 여유 공간. 송신 측이 이 값을 보고 전송량 조절.

**CWND (Congestion Window)**
- 송신 측이 혼잡 상황에 따라 자체 조절하는 윈도우 크기.

**UDP**
- 비연결형, 신뢰성 없는 전송 프로토콜 (Transport Layer). 데이터를 데이터그램 단위로 처리.  - TCP보다 속도 ↑
- 오류는 Application Layer에서 처리 필요
- 헤더 구성	: Source Port, Destination Port, Length, Checksum. 단순 구조로 오버헤드 적음.
- ex, 	실시간 방송, 온라인 게임, DNS

**IP의 역할과 UDP**
- 	IP는 장치 간 통신만 담당하며, UDP는 포트 번호를 사용하여 한 장치 내 여러 프로그램 간 통신을 지원.

**UDP 오류 해결**
- 자체적인 신뢰성 기능 없음. 오류 발생 시 재전송/순서 보정은 애플리케이션이 처리 (헤더 체크섬 정도만 제공).

**DNS와 UDP 통신 이유**
- 작은 데이터 크기 : DNS Request가 UDP segment에 담길 정도로 작음
- 연결 유지 불필요 : 3-way handshake 오버헤드 불필요
- Application Layer 제어: Timeout, Resend 등으로 신뢰성 보완 가능
- 포트: DNS는 UDP 53번 포트 사용

**HTTP(HyperText Transfer Protocol)**
- 웹에서 데이터를 주고받기 위한 비연결형·비상태형 통신 프로토콜
- 연결 유지 X, 데이터 암호화되지 않은 평문 전송 → 보안 취약.
- 포트 80

**HTTPS(HyperText Transfer Protocol Secure)**
- HTTP에 SSL/TLS를 적용한 보안 통신 프로토콜(하이브리드 암호화 방식 사용)
- 포트 443

**포트 (Port)**
- 프로세스 식별자. HTTP(80), HTTPS(443), DNS(53), SSH(22) 등.

**체크섬 (Checksum)**
- 전송 데이터 오류 검출용 필드 (TCP/UDP 헤더 포함).

---
### 질문답

**OSI 7 계층**

***1. 브라우저에서 GET /users 같은 REST API 호출 시, 데이터가 클라이언트에서 서버까지 가는 과정에서 OSI 계층별로 어떤 일이 일어날까?***
- ***응용 계층(7)***: HTTP 요청 메시지 생성 (GET /users HTTP/1.1)
  클라이언트 측 (송신): 데이터는 상위 계층에서 준비된 요청이 점점 낮은 계층으로 캡슐화(encapsulation) 되면서 실제 신호로 변환됨

    - 7계층 - 응용 계층: HTTP 요청 메시지 생성 (GET /users HTTP/1.1)
    - 6계층 - 표현 계층: 데이터 인코딩, HTTPS라면 SSL/TLS 암호화
    - 5계층 - 세션 계층: 세션 연결 관리, 세션 ID 생성
    - 4계층 - 전송 계층: TCP 세그먼트 생성, 포트 번호 추가 (출발지:랜덤, 목적지:80/443)
    - 3계층 - 네트워크 계층: IP 패킷 생성, IP 주소 추가, 라우팅 경로 결정
    - 2계층 - 데이터 링크 계층: 이더넷 프레임 생성, MAC 주소 추가
    - 1계층 - 물리 계층: 전기/광/무선 신호로 변환하여 전송

- ***네트워크 경로***: 중간 장치들은 패킷을 목적지까지 안전하게 전달하는 역할만 수행하고, 실제 데이터 내용은 변경하지 않음

    - 라우터: 3계층까지 처리, IP 헤더 확인 후 다음 홉으로 전달
    - 스위치: 2계층까지 처리, MAC 주소 기반으로 전달

- ***서버 측 (수신)***: 수신 측은 송신 계층에서 캡슐화된 데이터를 역순으로 해제(decapsulation) 하고 실제 요청 처리 수행
    - 1계층 - 물리 계층: 물리 신호를 디지털 데이터로 변환
    - 2계층 - 데이터 링크 계층: MAC 주소 확인, 프레임 검증
    - 3계층 - 네트워크 계층: IP 주소 확인, 패킷 검증
    - 4계층 - 전송 계층: 포트 확인, TCP 검증, 순서 재조립
    - 5계층 - 세션 계층: 세션 유효성 확인
    - 6계층 - 표현 계층: 복호화, 압축 해제
    - 7계층 - 응용 계층: HTTP 요청 파싱, 비즈니스 로직 처리


***2. 실무에서는 OSI 7계층보다 TCP/IP 4계층을 더 많이 쓰는 이유***
- OSI 7계층은 이론적 모델이고, TCP/IP 4계층은 실제 인터넷 프로토콜 기반
- TCP/IP가 더 단순하고 실용적
- 인터넷이 TCP/IP 기반으로 발전했기 때문에 실무에서는 TCP/IP 모델이 더 적합
- OSI의 5,6,7계층이 TCP/IP에서는 응용 계층으로 통합되어 있어 복잡도 감소
- 계층 단순화(TCP, IP, 애플리케이션) → 개발/디버깅 용이

**TCP/IP (흐름제어/혼잡제어)**

***1. TCP의 흐름 제어(RWND)와 혼잡 제어(CWND)는 각각 어떤 문제를 해결하며, 실제 전송 윈도우 계산 시 두 값은 어떻게 결합되는가?***
- ***RWND (Receiver Window)***
    - 수신 측 버퍼 크기에 따라 송신량 제한
    - 수신 측이 처리할 수 있는 만큼만 보내도록 조절 → 수신 과부하 방지
    - 동적으로 수신 가능 버퍼 크기를 ACK에 포함하여 - 송신 측에 알림

- ***CWND (Congestion Window)***
    - 네트워크 혼잡을 감지하고 전송량 조절
    - Slow Start, Congestion Avoidance, Fast Recovery 등을 통해 네트워크 혼잡 예방 및 효율적인 전송

- 실제 전송 윈도우 계산 시 윈도우 결정 방식
    - 수신 측 처리 가능량과 네트워크 상태 모두 고려해야 함
    - 송신 측이 한 번에 보낼 수 있는 데이터 크기는 min(RWND, CWND)

**HTTP & HTTPS**

***1. HTTPS는 왜 대칭키와 공개키를 동시에 사용할까? 두 방식을 결합하면 각각의 단점을 어떻게 보완할 수 있을까?***
- **공개키 암호화**
    - 서버 인증
    - 세션 키 안전하게 교환 가능
    - 단점: 연산 느림 → 대량 데이터 전송에는 비효율

- **대칭키 암호화**
    - 실제 데이터 전송에 사용 → 빠른 암호화/복호화
    - 단점: 안전하게 키 교환 필요

- **결합 장점**
    - 공개키로 세션 키를 안전하게 교환
    - 교환된 세션 키로 데이터 대칭 암호화 → 빠르고 안전한 통신

***2. CDN이란 무엇이고 어떤 역할을 할까?***
- **CDN(Content Delivery Network)**

    - 전 세계에 분산된 캐시 서버를 통해 사용자 근처에서 콘텐츠 제공
    - 이미지, JS, CSS, 동영상 등 정적 콘텐츠 전송 최적화

- **주요 역할**
    - **속도 향상**: 사용자와 가까운 서버에서 콘텐츠 제공 → 응답 시간 감소
    - **트래픽 분산**: 원본 서버 부하 감소 → 서버 안정성 향상
    - **보안 강화**: DDoS 공격 방어, HTTPS 적용 용이
    - **가용성**: 일부 서버 장애 발생 시 다른 서버가 콘텐츠 제공 → 서비스 중단 최소화
- **예시**: Cloudflare, Akamai, AWS CloudFront
